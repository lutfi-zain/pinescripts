// This Pine Script‚Ñ¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© 0xBujang

//@version=6
strategy(title="0xBujang - Reghimoku Sokud≈ç For Loop", overlay=true, default_qty_type = strategy.percent_of_equity, default_qty_value = 99 , initial_capital = 10000, calc_on_order_fills=true, calc_on_every_tick=true)

//                                                        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó                                                        //
//                                                        ‚ïë    Ichimoku Sokud≈ç For Loop    ‚ïë                                                        //
//                                                        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù                                                        //


//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //
//              ‚ïë      USER-DEFINED SETTINGS     ‚ïë              //
//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //

// Input Groups
var string zlag_settings    = "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Zero Lag Settings ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
var string loop_settings    = "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê For Loop Settings ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
var string thresh_settings  = "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Threshold Settings ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
var string visual_settings  = "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Visualization Settings ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
var string strategy_settings  = "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Strategy Settings ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"


// Tooltips
tooltip_zl_length     = "Length of the Zero Lag calculation period. Higher values create smoother signals."
tooltip_vol_mult      = "Multiplier for volatility in signal generation. Higher values make signals more conservative by requiring larger price movements."
tooltip_loop_start    = "Starting point for the loop analysis. Lower values analyze more recent price action."
tooltip_loop_end      = "Ending point for the loop analysis. Higher values analyze longer historical periods."
tooltip_thresh_up     = "Minimum score required to generate uptrend signals. Higher values create stricter conditions."
tooltip_thresh_down   = "Maximum score required to generate downtrend signals. Lower values create stricter conditions."
tooltip_signals       = "Enable/disable signal markers on the chart"
tooltip_candles       = "Enable/disable candle coloring based on trend direction"
tooltip_bg_lines      = "Enable/disable vertical lines on signal changes"

// Zero Lag Settings
length = input.int(50, "Zero Lag Length", 
     minval=1, 
     group=zlag_settings, 
     tooltip=tooltip_zl_length)
volatility_mult = input.float(0.9, "Volatility Multiplier", 
     minval=0.1, 
     group=zlag_settings, 
     tooltip=tooltip_vol_mult)

// Loop Settings
loop_start = input.int(1, "Loop Start", 
     minval=1, 
     group=loop_settings, 
     tooltip=tooltip_loop_start)
loop_end = input.int(70, "Loop End", 
     minval=1, 
     group=loop_settings, 
     tooltip=tooltip_loop_end)

// Threshold Settings
threshold_up = input.int(1, "Threshold Uptrend", 
     group=thresh_settings, 
     tooltip=tooltip_thresh_up)
threshold_down = input.int(-1, "Threshold Downtrend", 
     group=thresh_settings, 
     tooltip=tooltip_thresh_down)

// Visualization Settings

bullcolor = input.color(#ffdbac, "Bullish Color", group=visual_settings)
bearcolor = input.color(#96a4d3, "Bearish Color", group=visual_settings)
show_signals = input.bool(true, "Show Signal Markers", 
     group=visual_settings, tooltip=tooltip_signals)
show_trend_basis = input.bool(true, "Show Trend Basis", 
     group=visual_settings, tooltip=tooltip_signals)
paint_candles = input.bool(true, "Color Candles", 
     group=visual_settings, tooltip=tooltip_candles)
show_bg_lines = input.bool(false, "Signal Change Lines", 
     group=visual_settings, tooltip=tooltip_bg_lines)

// Strategy Settings
show_long   = input.bool(true,"Long Signal", group = strategy_settings)
show_short   = input.bool(false,"Short Signal", group = strategy_settings)
limit_backtest_time = input.bool(true,"Limit Backtest Time", group = strategy_settings)
backtest_start_at = input.time(defval = timestamp('01 Jan 2018 00:00 +0700'), title="Backtest Start At", group = strategy_settings)
reset_trend = input.bool(false, "Reset Trend When No Signal", group=strategy_settings)
exlude_hammer = input.bool(true, "üî® Exclude Hammer Fake-Out", group=strategy_settings)

// Ichimoku Input
show_ichimoku = input(false, title="Show Ichimoku Cloud")
ichimoku_sokudo = input(true, title="Activate Ichimoku Sokudo")
conversionPeriods = input.int(9, minval=1, title="Conversion Line Length")
basePeriods = input.int(26, minval=1, title="Base Line Length")
laggingSpan2Periods = input.int(52, minval=1, title="Leading Span B Length")
displacement = input.int(26, minval=1, title="Lagging Span")
donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
conversionLine = donchian(conversionPeriods)
baseLine = donchian(basePeriods)
leadLine1 = math.avg(conversionLine, baseLine)
leadLine2 = donchian(laggingSpan2Periods)


//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //
//              ‚ïë      ZERO LAG CALCULATIONS     ‚ïë              //
//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //

lag = math.floor((length - 1) / 2)
zl_basis = ta.ema(close + (close - close[lag]), length)
volatility = ta.highest(ta.atr(length), length*3) * volatility_mult

//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //
//              ‚ïë        FOR LOOP ANALYSIS       ‚ïë              //
//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //

forloop_analysis(basis_price) =>
    sum = 0.0
    for i = loop_start to loop_end by 1
        sum += (basis_price > basis_price[i] ? 1 : -1)
    sum

score = forloop_analysis(zl_basis)

// Ichimoku
currentSSA = leadLine1[26]
currentSSB = leadLine2[26]

kumoHigh = math.max(currentSSA, currentSSB)
kumoLow  = math.min(currentSSA, currentSSB)

bodyLow  = math.min(open, close)
bodyHigh = math.max(open, close)

// üü¢/üî¥ Kumo "Color" logic (SSA above SSB is green, otherwise red)
is_current_kumo_green = currentSSA > currentSSB
is_current_kumo_red   = currentSSA < currentSSB

is_kumo_green = leadLine1 > leadLine2  // 26 bars ahead
is_kumo_red   = leadLine1 < leadLine2

// ‚úÖ Body positions relative to current Kumo (SSA & SSB from 26 bars ago)
is_whole_body_inside_current_kumo = bodyLow >= kumoLow and bodyHigh <= kumoHigh
is_whole_body_above_current_kumo  = bodyLow > kumoHigh
is_whole_body_under_current_kumo  = bodyHigh <= kumoLow

// ‚úÖ Tenkan-sen x Kijun-sen
is_tk_above_kj =  baseLine > conversionLine
is_tk_equal_kj = baseLine == conversionLine
is_whole_body_under_tkkj = open <= math.min(conversionLine,baseLine) and close < math.min(conversionLine,baseLine)

// Hammer Calculation
body = math.abs(close - open)
upperWick = high - math.max(open, close)
lowerWick = math.min(open, close) - low

isHammer = lowerWick > (1.7 * body) and upperWick <= body * 0.3

// Hammer Debug
// plotshape(isHammer, title="Hammer", location=location.belowbar, color=color.green, style=shape.labelup, text="Hammer")




//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //
//              ‚ïë        SIGNAL GENERATION       ‚ïë              //
//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //

// Long/Short conditions
long_signal = score > threshold_up and close > zl_basis + volatility
short_signal = score < threshold_down and close < zl_basis - volatility

// Trend detection
var trend = 0
if long_signal
    trend := 1
else if short_signal
    if ichimoku_sokudo 
        if is_current_kumo_green and is_whole_body_under_current_kumo and (exlude_hammer ? not isHammer : true) // === ‚ö†Ô∏è Prevent Close if Still in Kouten Trend
            trend := -1
    else 
        trend := -1
else if reset_trend
    trend := 0

log.info("isHammer: " + str.tostring(isHammer))

// === ‚ö†Ô∏è Early Close for Sanyaku Gyakuten
if ichimoku_sokudo and is_kumo_red and is_whole_body_under_current_kumo and (is_tk_above_kj or is_tk_equal_kj) and (exlude_hammer ? not isHammer : true) // and is_whole_body_under_tkkj
    trend := -1

// Track trend changes
var prev_trend = 0
trend_changed = trend != prev_trend
prev_trend := trend

// Condition
longCondition = (trend_changed and trend == 1) and (limit_backtest_time ? time > backtest_start_at : true)
shortCondition = (trend_changed and trend == -1) and (limit_backtest_time ? time > backtest_start_at : true)

finalLongCondition = longCondition
finalShortCondition =  shortCondition

//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //
//              ‚ïë             STRATEGY           ‚ïë              //
//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //

if longCondition
    if show_long
        strategy.entry("Long", strategy.long)
    if show_short
        strategy.close("Short")

// === ‚ö†Ô∏è Early Close for Sanyaku Gyakuten 
if ichimoku_sokudo and is_kumo_red and is_whole_body_under_current_kumo and is_whole_body_under_tkkj and (is_tk_above_kj or is_tk_equal_kj) and (exlude_hammer ? not isHammer : true)
    if show_long
        strategy.close("Long")

if shortCondition
    if show_long
        if ichimoku_sokudo 
            if is_current_kumo_green and is_whole_body_under_current_kumo and (exlude_hammer ? not isHammer : true) // === ‚ö†Ô∏è Prevent Close if Still in Kouten Trend
                strategy.close("Long")
        else 
            strategy.close("Long")
    if show_short
        strategy.entry("Short", strategy.short)

//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //
//              ‚ïë             ALERTS             ‚ïë              //
//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //

alertcondition(ta.crossover(trend, 0),
     title="Zero Lag Signals Long",
     message="Zero Lag Signals Long {{exchange}}:{{ticker}}")

alertcondition(ta.crossunder(trend, 0),
     title="Zero Lag Signals Short",
     message="Zero Lag Signals Short {{exchange}}:{{ticker}}")

//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //
//              ‚ïë         VISUALIZATION          ‚ïë              //
//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //

// Current trend color
trend_col = trend == 1 ? bullcolor : trend == -1 ? bearcolor : na

// Plot Zero Lag line
p_basis = plot(show_trend_basis ? zl_basis : na, "Zero Lag Basis", color=trend_col, linewidth=3)
p_price = plot(hl2, "Price", display=display.none, editable=false)

// Fill between Zero Lag and price
fill(p_basis, p_price, hl2, show_trend_basis ? zl_basis : na, na, color.new(trend_col, 20))

// Plot trend shift labels
plotshape(longCondition and show_signals ? zl_basis : na, "Bullish Trend", 
     shape.labelup, location.absolute, bullcolor, 
     text="ùë≥", textcolor=#000000, size=size.small, force_overlay=true)

plotshape(shortCondition and show_signals ? zl_basis : na, "Bearish Trend", 
     shape.labeldown, location.absolute, bearcolor, 
     text="ùë∫", textcolor=#ffffff, size=size.small, force_overlay=true)

// Background signal lines
bgcolor(show_bg_lines ? 
     (ta.crossover(trend, 0) ? bullcolor : 
      ta.crossunder(trend, 0) ? bearcolor : na) : na)


// Color candles based on trend
barcolor(paint_candles ? 
     (trend == 1 ? bullcolor : 
      trend == -1 ? bearcolor : na) : na)

// Ichimoku
plot(show_ichimoku ? conversionLine : na, color=#2962FF, title="Conversion Line")
plot(show_ichimoku ? baseLine : na, color=#B71C1C, title="Base Line")
plot(show_ichimoku ? close : na, offset = -displacement + 1, color=#43A047, title="Lagging Span")
p1 = plot(show_ichimoku ? leadLine1 : na, offset = displacement - 1, color=#A5D6A7,title="Leading Span A")
p2 = plot(show_ichimoku ? leadLine2 : na , offset = displacement - 1, color=#EF9A9A,title="Leading Span B")
plot(show_ichimoku ? (leadLine1 > leadLine2 ? leadLine1 : leadLine2) : na, offset = displacement - 1, title = "Kumo Cloud Upper Line", display = display.none) 
plot(show_ichimoku ? (leadLine1 < leadLine2 ? leadLine1 : leadLine2) : na, offset = displacement - 1, title = "Kumo Cloud Lower Line", display = display.none) 
fill(p1, p2, color = leadLine1 > leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 90), title = "Kumo Cloud Color")

//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //
//              ‚ïë        GENERAL FUNCTION        ‚ïë              //
//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //

// Logging function
// log_event(_price, _object, _toLabel=false) =>
//     // Format timestamp
//     ts = str.tostring(year) + "-" + str.tostring(month, "00") + "-" + str.tostring(dayofmonth, "00") + " " + str.tostring(hour, "00") + ":" + str.tostring(minute, "00") + ":" + str.tostring(second, "00")

//     msg = ts + " | " + str.tostring(_price, format.mintick) + " | " + str.tostring(_object)

//     if _toLabel
//         label.new(bar_index, low, text=msg, style=label.style_label_up, size=size.small, textcolor=color.white, color=color.gray)
//     else    
//         log.info(msg)


//                                                        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó                                                        //
//                                                        ‚ïë        Adaptive Regime         ‚ïë                                                        //
//                                                        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù                                                        //

// This script uses higher timeframe values for RSI/MACD, integrated into regime detection and scoring.
// Logic uses closed HTF bars to avoid repainting.

// D=====================================================Z
// 1. ATR SETTINGS==Z
// D=====================================================Z
group_atr = "‚ö° ATR Settings"
atr_period     = input.int(14, "ATR Period", minval=1, group=group_atr)
atr_multiplier = input.float(1.5, "ATR Multiplier", minval=0.1, step=0.1, group=group_atr)
atr_val        = ta.atr(atr_period)
atr_avg        = ta.sma(atr_val, 50)

// D=====================================================Z
// 2. MOVING AVERAGE (MA) SETTINGS==Z
// D=====================================================Z
group_ma = "üìä Moving Averages"
fast_ma_length        = input.int(9, "Fast MA Length", minval=1, group=group_ma)
slow_ma_length        = input.int(34, "Slow MA Length", minval=1, group=group_ma)
ma_fast               = ta.ema(close, fast_ma_length)
ma_slow               = ta.ema(close, slow_ma_length)
ma_strength_threshold = input.float(0.5, "MA Strength Threshold", minval=0.0, step=0.1, group=group_ma)
trend_dir = ma_fast > ma_slow + (atr_val * ma_strength_threshold) ? 1 : ma_fast < ma_slow - (atr_val * ma_strength_threshold) ? -1 : 0

// D=====================================================Z
// 3. MULTI-TIMEFRAME (HTF) SETTINGS==Z
// D=====================================================Z
group_MTA = "‚è±Ô∏è Multi-Timeframe Inputs"
htf = input.timeframe("D", "HTF for RSI & MACD", group=group_MTA)
htf_rsi_raw = request.security(syminfo.tickerid, htf, ta.rsi(close, 14))
htf_rsi = htf_rsi_raw[1]
[htf_macd_line_raw, htf_macd_signal_raw, htf_macd_hist_raw] = request.security(syminfo.tickerid, htf, ta.macd(close, 12, 26, 9))
htf_macd_line = htf_macd_line_raw[1]
htf_macd_signal = htf_macd_signal_raw[1]
htf_macd_hist = htf_macd_hist_raw[1]
// new: HTF trend direction for regime detection
htf_trend_bull = htf_macd_line > htf_macd_signal and htf_rsi > 50
htf_trend_bear = htf_macd_line < htf_macd_signal and htf_rsi < 50

// D=====================================================Z
// 4. TRADE SETTINGS==Z
// D=====================================================Z
group_trade = "‚öôÔ∏è Trade Settings"
risk_per_trade      = input.int(500, "Risk per Trade ($)", minval=50, group=group_trade)
max_contracts       = input.int(1, "Max Contracts", minval=1, group=group_trade)
max_daily_drawdown  = input.float(0.05, "Max Daily Drawdown (%)", minval=0.01, group=group_trade)
tick_value          = input.float(12.5, "Tick Value ($)", minval=0.01, group=group_trade)
ticks_per_point     = input.int(4, "Ticks per Point", minval=1, group=group_trade)
default_stop_points = input.float(8.0, "Default Stop (Points)", minval=0.25, group=group_trade)
execute_long        = input.bool(false, "Execute Long Signal", group=group_trade)
long_threshold      = input.float(0.55, "Long Execution Threshold", group=group_trade)
execute_short       = input.bool(false, "Execute Short Signal", group=group_trade)
short_threshold     = input.float(1, "Short Execution Threshold", group=group_trade)

// D=====================================================Z
// 5. ADVANCED INDICATOR CALCULATIONS==Z
// D=====================================================Z

// --- ADX Calculation ---Z
adx_len   = 14
up        = ta.change(high)
down      = -ta.change(low)
plus_dm   = na(up) ? na : (up > down and up > 0 ? up : 0)
minus_dm  = na(down) ? na : (down > up and down > 0 ? down : 0)
trur      = ta.rma(ta.tr, adx_len)
plus_di   = 100 * ta.rma(plus_dm, adx_len) / trur
minus_di  = 100 * ta.rma(minus_dm, adx_len) / trur
adx_val   = 100 * ta.rma(math.abs(plus_di - minus_di) / (plus_di + minus_di), adx_len)

// --- Bollinger Bands Calculation ---Z
bb_basis     = ta.sma(close, 20)
bb_dev       = 2 * ta.stdev(close, 20)
bb_upper     = bb_basis + bb_dev
bb_lower     = bb_basis - bb_dev
bb_width     = (bb_upper - bb_lower) / bb_basis
bb_width_avg = ta.sma(bb_width, 50)

// --- Price Action Range ---Z
price_range = ta.highest(high, 20) - ta.lowest(low, 20)
range_ratio = price_range / close

// D=====================================================Z
// 6. REGIME ASSIGNMENT & PATTERN RECOGNITION==Z
// D=====================================================Z

// Regime assignment with HTF influence and looser thresholds
is_trending = adx_val > 20 and math.abs(ma_fast - ma_slow) > atr_val * 0.3 and htf_trend_bull or htf_trend_bear // loosened ADX and MA thresholds, added HTF
is_range    = adx_val < 25 and range_ratio < 0.03 and not htf_trend_bull and not htf_trend_bear // loosened ADX and range, HTF neutral
is_volatile = bb_width > bb_width_avg * 1.5 and atr_val > atr_avg * 1.2 and (htf_rsi > 70 or htf_rsi < 30) // loosened BB/ATR, added HTF overbought/oversold
is_quiet    = bb_width < bb_width_avg * 0.8 and atr_val < atr_avg * 0.9 // loosened BB/ATR
regime      = is_trending ? 1 : is_range ? 2 : is_volatile ? 3 : is_quiet ? 4 : 5
regime_name = regime == 1 ? "Trending" : regime == 2 ? "Range" : regime == 3 ? "Volatile" : regime == 4 ? "Quiet" : "Other"

// Pattern Recognition & Volume Confirmation-Z
vol_avg       = ta.sma(volume, 20)
vol_spike     = volume > vol_avg * 1.5
recent_low    = ta.lowest(low, 20)
recent_high   = ta.highest(high, 20)
is_near_support    = low <= recent_low * 1.01
is_near_resistance = high >= recent_high * 0.99

bullish_engulfing = close[1] < open[1] and close > open and close > open[1] and open < close[1] and is_near_support and vol_spike
hammer            = high - low > 3 * math.abs(open - close) and (close - low) / (0.001 + high - low) > 0.6 and is_near_support and vol_spike
morning_star      = close[2] < open[2] and math.abs(close[1] - open[1]) < 0.2 * (high[1] - low[1]) and close > open and close > (open[2] + close[2]) / 2 and is_near_support and vol_spike
piercing          = close[1] < open[1] and close > open and close > (open[1] + close[1]) / 2 and open < close[1] and is_near_support and vol_spike
double_bottom     = low < low[1] and low[1] > low[2] and low[2] < low[3] and close > open and is_near_support and vol_spike

bearish_engulfing = close[1] > open[1] and close < open and close < open[1] and open > close[1] and is_near_resistance and vol_spike
shooting_star     = high - low > 3 * math.abs(open - close) and (high - close) / (0.001 + high - low) > 0.6 and is_near_resistance and vol_spike
evening_star      = close[2] > open[2] and math.abs(close[1] - open[1]) < 0.2 * (high[1] - low[1]) and close < open and close < (open[2] + close[2]) / 2 and is_near_resistance and vol_spike
dark_cloud        = close[1] > open[1] and close < open and close < (open[1] + close[1]) / 2 and open > close[1] and is_near_resistance and vol_spike
double_top        = high > high[1] and high[1] < high[2] and high[2] > high[3] and close < open and is_near_resistance and vol_spike

bull_signal = (bullish_engulfing ? 0.5 : 0.0) +
              (hammer ? (regime == 2 ? 0.4 : 0.2) : 0.0) +
              (morning_star ? 0.2 : 0.0) +
              (piercing ? 0.2 : 0.0) +
              (double_bottom ? (regime == 3 ? 0.3 : 0.15) : 0.0)

bear_signal = (bearish_engulfing ? 0.5 : 0.0) +
              (shooting_star ? (regime == 2 ? 0.4 : 0.2) : 0.0) +
              (evening_star ? 0.2 : 0.0) +
              (dark_cloud ? 0.2 : 0.0) +
              (double_top ? (regime == 3 ? 0.3 : 0.15) : 0.0)

// Multi-Factor Confirmation with HTF-Z
rsi_val   = ta.rsi(close, 14)
[macd_line, macd_signal, macd_hist] = ta.macd(close, 12, 26, 9)
trend_bull = ma_fast > ma_slow
trend_bear = ma_fast < ma_slow
rsi_bull   = rsi_val < 30
rsi_bear   = rsi_val > 70
macd_bull  = macd_line > macd_signal
macd_bear  = macd_line < macd_signal
vol_expansion = atr_val > atr_avg * 1.2
// new: HTF confirmation for scoring
htf_bull_confirm = htf_trend_bull and htf_rsi < 70
htf_bear_confirm = htf_trend_bear and htf_rsi > 30

bull_score = bull_signal + (trend_bull ? 0.2 : 0) + (rsi_bull ? 0.15 : 0) + (macd_bull ? 0.15 : 0) + (vol_expansion ? 0.1 : 0) + (htf_bull_confirm ? 0.2 : 0)
bear_score = bear_signal + (trend_bear ? 0.2 : 0) + (rsi_bear ? 0.15 : 0) + (macd_bear ? 0.15 : 0) + (vol_expansion ? 0.1 : 0) + (htf_bear_confirm ? 0.2 : 0)

// D=====================================================Z
// 7. PERFORMANCE TRACKING & ADAPTIVE THRESHOLDS==Z
// D=====================================================Z
var float[] regime_pnl_long  = array.new_float(5, 0)
var float[] regime_pnl_short = array.new_float(5, 0)
var int[] regime_win_long    = array.new_int(5, 0)
var int[] regime_loss_long   = array.new_int(5, 0)
var int[] regime_win_short   = array.new_int(5, 0)
var int[] regime_loss_short  = array.new_int(5, 0)
var int entry_regime = na

if barstate.isconfirmed and strategy.closedtrades > 0 and not na(entry_regime)
    last_trade_profit = strategy.closedtrades.profit(strategy.closedtrades - 1)
    last_trade_entry_id = strategy.closedtrades.entry_id(strategy.closedtrades - 1)
    idx = entry_regime - 1
    if last_trade_entry_id == "Long"
        array.set(regime_pnl_long, idx, array.get(regime_pnl_long, idx) + last_trade_profit)
        if last_trade_profit > 0
            array.set(regime_win_long, idx, array.get(regime_win_long, idx) + 1)
        else
            array.set(regime_loss_long, idx, array.get(regime_loss_long, idx) + 1)
    else if last_trade_entry_id == "Short"
        array.set(regime_pnl_short, idx, array.get(regime_pnl_short, idx) + last_trade_profit)
        if last_trade_profit > 0
            array.set(regime_win_short, idx, array.get(regime_win_short, idx) + 1)
        else
            array.set(regime_loss_short, idx, array.get(regime_loss_short, idx) + 1)
    entry_regime := na

// D=====================================================Z
// 8. DRAWDOWN & CIRCUIT BREAKER==Z
// D=====================================================Z
var float max_equity = strategy.equity
if strategy.equity > max_equity
    max_equity := strategy.equity
daily_drawdown = (max_equity - strategy.equity) / max_equity
pause_trading  = daily_drawdown > max_daily_drawdown

// D=====================================================Z
// 9. ENTRY & EXIT LOGIC WITH DYNAMIC STOPS & TRAILING STOPS=Z
// D=====================================================Z
swing_low  = ta.lowest(low, 5)
swing_high = ta.highest(high, 5)
long_condition  = bull_score >= long_threshold // and not pause_trading
short_condition = bear_score >= short_threshold // and not pause_trading
last_signal = 0  // 0: netral, 1: long, -1: short


var float trail_stop_long  = na
var float trail_stop_short = na
var float long_stop_price  = na
var float long_limit_price = na
var float short_stop_price = na
var float short_limit_price = na

var bool show_long_signal_once = false
var bool show_short_signal_once = false


if long_condition and last_signal != 1 and (limit_backtest_time ? time > backtest_start_at : true)
//     intended_stop = swing_low - atr_multiplier * atr_val
//     stop_distance_points = close - intended_stop
//     risk_per_contract = stop_distance_points * syminfo.pointvalue
//     contracts = math.floor(risk_per_trade / risk_per_contract)
//     contracts := contracts > 0 ? contracts : 1
//     contracts := math.min(contracts, max_contracts)
//     long_limit = close + stop_distance_points * 2
//     strategy.entry("Long", strategy.long, qty = contracts)
//     strategy.exit("Exit", from_entry = "Long", stop = intended_stop, limit = long_limit)
//     strategy.close("Short")  // pastikan posisi short ditutup
    if execute_long
        strategy.entry("Long", strategy.long)
//     long_stop_price  := intended_stop
//     long_limit_price := long_limit
//     trail_stop_long  := intended_stop
//     entry_regime     := regime
    last_signal := 1

if short_condition and last_signal != -1 and (limit_backtest_time ? time > backtest_start_at : true)
//     intended_stop = swing_high + atr_multiplier * atr_val
//     stop_distance_points = intended_stop - close
//     risk_per_contract = stop_distance_points * syminfo.pointvalue
//     contracts = math.floor(risk_per_trade / risk_per_contract)
//     contracts := contracts > 0 ? contracts : 1
//     contracts := math.min(contracts, max_contracts)
//     short_limit = close - stop_distance_points * 2
//     strategy.entry("Short", strategy.short, qty = contracts)
//     strategy.exit("Exit", from_entry = "Short", stop = intended_stop, limit = short_limit)
    strategy.close("Long")  // pastikan posisi long ditutup
    if execute_short
        strategy.entry("Short", strategy.short)
//     short_stop_price  := intended_stop
//     short_limit_price := short_limit
//     trail_stop_short  := intended_stop
//     entry_regime      := regime
    last_signal := -1

// if strategy.position_size > 0
//     if close > long_limit_price * 0.5
//         trail_stop_long := math.max(trail_stop_long, close - atr_val * atr_multiplier)
//     strategy.exit("Long Trailing Stop", from_entry = "Long", stop = trail_stop_long)

// if strategy.position_size < 0
//     if close < short_limit_price * 0.5
//         trail_stop_short := math.min(trail_stop_short, close + atr_val * atr_multiplier)
//     strategy.exit("Short Trailing Stop", from_entry = "Short", stop = trail_stop_short)

if strategy.position_size == 0
    long_stop_price  := na
    long_limit_price := na
    short_stop_price := na
    short_limit_price := na

// D=====================================================Z
// 10. VISUALIZATION==Z
// D=====================================================Z
bgcolor(regime == 1 ? color.new(color.green, 85) : 
       regime == 2 ? color.new(color.orange, 85) : 
       regime == 3 ? color.new(color.red, 85) : 
       regime == 4 ? color.new(color.gray, 85) : 
       color.new(color.navy, 85), display=display.none)

plotshape(long_condition and nz(last_signal[1]) != 1, title="Long Entry (Once)", location=location.belowbar, color=color.rgb(97, 76, 175), style=shape.triangleup, size=size.small, display=display.none)
plotshape(short_condition and nz(last_signal[1]) != -1, title="Short Entry (Once)", location=location.abovebar, color=color.rgb(226, 255, 82), style=shape.triangledown, size=size.small, display=display.none)
plot(ma_fast, "Fast MA", color=color.new(color.blue, 0), linewidth=2, display=display.none)
plot(ma_slow, "Slow MA", color=color.new(color.red, 0), linewidth=2, display=display.none)
plot(strategy.position_size > 0 ? long_stop_price  : na, "Long Stop", color=color.new(color.red, 0), style=plot.style_linebr, display=display.none)
plot(strategy.position_size > 0 ? long_limit_price : na, "Long Target", color=color.new(color.green, 0), style=plot.style_linebr, display=display.none)
plot(strategy.position_size < 0 ? short_stop_price  : na, "Short Stop", color=color.new(color.red, 0), style=plot.style_linebr, display=display.none)
plot(strategy.position_size < 0 ? short_limit_price : na, "Short Target", color=color.new(color.green, 0), style=plot.style_linebr, display=display.none)

// D=====================================================Z
// 11. DASHBOARD: METRICS TABLE (Bottom-Left)=Z
// D=====================================================Z
var table dashboard = table.new(position.bottom_left, 2, 15, bgcolor=color.new(#000000, 29), border_color=color.rgb(80,80,80), border_width=1)
if barstate.islast
    table.cell(dashboard, 0, 0, "üå§Ô∏è Regime Details", text_color=#ffdbac, text_size=size.small)
    table.merge_cells(dashboard, 0, 0, 1, 0)
    modeStr = pause_trading ? "Paused" : "Active"
    table.cell(dashboard, 0, 1, "Mode:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 1, modeStr, text_color=color.white, text_size=size.small)
    trendText = trend_dir == 1 ? "Bullish" : trend_dir == -1 ? "Bearish" : "Neutral"
    table.cell(dashboard, 0, 2, "Trend:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 2, trendText, text_color=trend_dir == 1 ? color.green : trend_dir == -1 ? color.red : color.gray, text_size=size.small)
    table.cell(dashboard, 0, 3, "ATR:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 3, str.tostring(atr_val, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(dashboard, 0, 4, "ATR Avg:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 4, str.tostring(atr_avg, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(dashboard, 0, 5, "Volume Spike:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 5, vol_spike ? "YES" : "NO", text_color=vol_spike ? color.green : color.red, text_size=size.small)
    table.cell(dashboard, 0, 6, "RSI:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 6, str.tostring(rsi_val, "#.##"), text_color=color.white, text_size=size.small)
    rsiCondText = rsi_val < 30 ? "Oversold" : rsi_val > 70 ? "Overbought" : "Neutral"
    table.cell(dashboard, 0, 7, "RSI Cond:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 7, rsiCondText, text_color=color.white, text_size=size.small)
    table.cell(dashboard, 0, 8, "HTF RSI:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 8, str.tostring(htf_rsi, "#.##"), text_color=color.white, text_size=size.small)
    htfTrendText = htf_trend_bull ? "Bullish" : htf_trend_bear ? "Bearish" : "Neutral"
    table.cell(dashboard, 0, 9, "HTF Trend:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 9, htfTrendText, text_color=htf_trend_bull ? color.green : htf_trend_bear ? color.red : color.gray, text_size=size.small)
    lastSignal = long_condition ? "Buy" : short_condition ? "Sell" : "None"
    table.cell(dashboard, 0, 10, "Last Signal:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 10, lastSignal, text_color=long_condition ? color.green : short_condition ? color.red : color.white, text_size=size.small)
    table.cell(dashboard, 0, 11, "Regime:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 11, regime_name, text_color=color.white, text_size=size.small)
    table.cell(dashboard, 0, 12, "Bull Score:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 12, str.tostring(bull_score, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(dashboard, 0, 13, "Bear Score:", text_color=color.white, text_size=size.small)
    table.cell(dashboard, 1, 13, str.tostring(bear_score, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(dashboard, 0, 14, "", text_color=color.new(color.white, 100))
    table.merge_cells(dashboard, 0, 14, 1, 14)
//     table.cell(dashboard, 0, 15, "", text_color=color.new(color.white, 100))
//     table.cell(dashboard, 1, 15, "", text_color=color.new(color.white, 100))

// D=====================================================Z
// REGIME CONDITIONS
// D=====================================================Z
var table debug_table = table.new(position.top_right, 2, 5, bgcolor=color.new(#000000, 50), border_color=color.rgb(80,80,80), border_width=1)
if barstate.islast
    table.cell(debug_table, 0, 0, "Regime Conditions", text_color=#ffdbac, text_size=size.small)
    table.merge_cells(debug_table, 0, 0, 1, 0)
    table.cell(debug_table, 0, 1, "ADX:", text_color=color.white, text_size=size.small)
    table.cell(debug_table, 1, 1, str.tostring(adx_val, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(debug_table, 0, 2, "BB Width Ratio:", text_color=color.white, text_size=size.small)
    table.cell(debug_table, 1, 2, str.tostring(bb_width / bb_width_avg, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(debug_table, 0, 3, "ATR Ratio:", text_color=color.white, text_size=size.small)
    table.cell(debug_table, 1, 3, str.tostring(atr_val / atr_avg, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(debug_table, 0, 4, "Range Ratio:", text_color=color.white, text_size=size.small)
    table.cell(debug_table, 1, 4, str.tostring(range_ratio, "#.##"), text_color=color.white, text_size=size.small)

// --- Bollinger Bands Visuals ---Z
p_bb_basis = plot(bb_basis, title="BB Basis", color=color.new(#ffffff, 50), linewidth=1, display=display.none)
p_bb_upper = plot(bb_upper, title="BB Upper", color=color.new(#4caf4f, 45), linewidth=2, display=display.none)
p_bb_lower = plot(bb_lower, title="BB Lower", color=color.new(#ff5252, 45), linewidth=2, display=display.none)
fill(p_bb_upper, p_bb_lower, color=color.new(#423645, 65), display=display.none)

//D=================================================================Z
// DASHBOARD: WATERMARK LOGO (Bottom-Right)
//D=================================================================Z
var table watermarkTable = table.new(position.bottom_right, 1, 1, bgcolor=color.rgb(0,0,0,80), border_color=color.rgb(0,50,137), border_width=1)
if barstate.islast
    table.cell(watermarkTable, 0, 0, "‚õÖ 0xBujang - Reghimoku Sokud≈ç For Loop", text_color=#ffdbac, text_size=size.normal, text_formatting = text.format_italic)

// --- ALERTS ---Z
alertcondition(long_condition, title="Long Signal Alert", message="Enhanced Strategy Long Signal")
alertcondition(short_condition, title="Short Signal Alert", message="Enhanced Strategy Short Signal")



// Credits: This code is partially authored by QuantAlgo and Dskyz